<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAFS' Secret Garden DP Frame</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CDN for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Google Fonts for Playfair Display and Lora -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght%40700&family=Lora:wght%40400%3B700&display=swap" rel="stylesheet">
    <style>
        /* Root variables and general body styling */
        :root {
            --primary-gold: #B8860B; /* DarkGoldenrod - a rich, deep gold */
            --light-gold: #DAA520; /* Goldenrod - a vibrant gold */
            --soft-cream: #FFF8E1; /* A very light, warm cream */
            --warm-white: #FFFAF0; /* Floral White */
            --accent-gold: #FFD700; /* Gold - a brighter gold */
            --dark-text: #333333; /* Dark gray for text */
            --light-text: #FFFFFF; /* White for text on dark backgrounds */
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.2);
            --shadow-strong: rgba(0, 0, 0, 0.4);
            --border-radius-soft: 8px;
            --border-radius-round: 50%;
        }

        /* General body styling */
        body {
            box-sizing: border-box;
            margin: 0;
            font-family: 'Lora', serif;
            color: var(--dark-text);
            background-image: url('Background.png'); /* Ensure this path is correct */
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top initially, allow content to push down */
            min-height: 100vh;
            padding: 20px; /* Added general padding to body */
            position: relative;
        }

        /* Header and Logo Styling */
        .header-content {
            margin-bottom: 20px;
            opacity: 0; /* Initially hidden for fade-in effect */
            transform: translateY(-20px); /* Initially slightly above for slide-in effect */
            animation: fadeInSlideDown 1.5s ease-out forwards;
        }

        @keyframes fadeInSlideDown {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo-image {
            max-width: 350px; /* Adjust max-width for responsiveness */
            height: auto;
            display: block;
            margin: 0 auto;
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.7)); /* Soft white glow */
        }

        /* Main Container Styling */
        .container {
            background-color: var(--soft-cream);
            border-radius: var(--border-radius-soft);
            box-shadow: 0 10px 25px var(--shadow-strong);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            max-width: 900px; /* Max width for the container */
            width: calc(100% - 40px); /* Responsive width with 20px margin on each side (from body padding) */
            margin: 0 auto 40px auto; /* Centered with space from bottom */
            opacity: 0; /* Initially hidden for fade-in effect */
            transform: translateY(20px); /* Initially slightly below for slide-in effect */
            animation: fadeInSlideUp 1.5s ease-out 0.5s forwards; /* Delayed animation */
            z-index: 10; /* Ensure container is above background */
            position: relative; /* Needed for z-index to work */
            min-height: fit-content; /* Ensure container expands to fit content */
        }

        @keyframes fadeInSlideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Global styling for individual action-buttons (Choose Photo, Download, Add Caption, Modal buttons) */
        .action-button {
            background-color: var(--warm-white); /* White background */
            color: var(--primary-gold); /* Gold text */
            padding: 15px 30px; /* Consistent padding */
            border-radius: var(--border-radius-soft);
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, border-color 0.3s ease, color 0.3s ease;
            font-weight: bold;
            border: 2px solid var(--primary-gold); /* Gold border */
            text-transform: uppercase;
            text-align: center;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 0 auto;
            width: 100%; /* Default to full width on small screens */
            max-width: 280px; /* Max width for consistency */
            box-shadow: 0 5px 15px var(--shadow-medium); /* Shadow */
        }

        /* General hover effect for all action-buttons */
        .action-button:hover:not(:disabled) {
            background-color: var(--primary-gold); /* Gold background on hover */
            color: var(--light-text); /* White text on hover */
            transform: translateY(-2px);
            border-color: var(--primary-gold); /* Keep border gold on hover */
        }

        /* General disabled state styling for all action-buttons */
        .action-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            color: #666666;
            border-color: #999999;
            box-shadow: none;
        }

        /* Specific styling for the Choose Photo button's wrapper */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
        }

        .file-input-wrapper input[type="file"] {
            display: none;
        }

        /* Main Content Area (Canvas and Controls) */
        .main-content-area {
            display: flex;
            flex-direction: row; /* Default to row layout */
            gap: 25px;
            width: 100%;
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
        }

        /* Canvas Styling */
        .canvas-container {
            flex-shrink: 0; /* Prevent shrinking */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            position: relative; /* For positioning the Facebook toggle */
            z-index: 20; /* Ensure canvas is above container */
            /* Added padding to ensure space from container edges */
            padding: 10px;
            box-sizing: border-box; /* Include padding in width/height */
        }

        #imageCanvas {
            border: 0px solid #ddd;
            border-radius: var(--border-radius-soft);
            background-color: var(--warm-white);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            cursor: grab; /* Indicates draggable */
            touch-action: none; /* Disable default touch actions to handle custom panning/zooming */
        }

        #imageCanvas.grabbing {
            cursor: grabbing; /* Indicates being dragged */
        }

        /* Facebook Profile View Toggle Switch */
        .facebook-toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .facebook-toggle-container label {
            font-weight: bold;
            color: var(--dark-text);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-gold);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-gold);
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }

        /* Controls Container */
        .controls-container {
            flex-grow: 1; /* Allow controls to take available space */
            background-color: var(--warm-white);
            border-radius: var(--border-radius-soft);
            box-shadow: 0 5px 15px var(--shadow-medium);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 350px; /* Max width for controls */
            width: 100%; /* Responsive width */
            z-index: 20; /* Ensure controls are above container */
            box-sizing: border-box; /* Include padding in width/height */
        }

        .tabs-header {
            display: flex;
            border-bottom: 2px solid var(--soft-cream);
        }

        .tab-button {
            flex: 1;
            padding: 10px 15px;
            background-color: var(--soft-cream); /* Explicit background for tabs */
            color: var(--dark-text);
            border: none;
            border-radius: var(--border-radius-soft) var(--border-radius-soft) 0 0;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .tab-button.active {
            background-color: var(--warm-white);
            color: var(--primary-gold);
            border-bottom: 2px solid var(--primary-gold);
        }

        .tab-content {
            display: none; /* Hidden by default */
            padding-top: 15px;
            flex-direction: column;
            gap: 15px;
        }

        .tab-content.active {
            display: flex; /* Active tab content visible */
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
            color: var(--primary-gold);
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center; /* Centered label for landscape */
        }

        .control-buttons-group {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            width: 100%;
            flex-wrap: wrap; /* Allow buttons to wrap */
        }

        .control-sub-button {
            background-color: var(--light-gold);
            color: var(--light-text);
            border: none;
            border-radius: var(--border-radius-soft);
            padding: 10px 15px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            flex-grow: 1;
            min-width: 45%; /* Ensure two buttons per row on larger screens */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .control-sub-button:hover {
            background-color: var(--primary-gold);
            transform: translateY(-2px);
        }

        /* Specific text capitalization for zoom, rotate, flip buttons */
        .control-sub-button .button-text {
            text-transform: capitalize;
        }

        /* Reset buttons centered */
        #revertPhotoBtn, #revertFiltersBtn { /* Updated ID for filter reset button */
            display: block;
            margin: 20px auto 0 auto; /* Center horizontally */
        }

        /* Range Slider Styling */
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none; /* Hides the default slider */
            height: 8px;
            background: #ddd;
            outline: none;
            border-radius: 5px;
            transition: opacity .2s;
            margin-top: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary-gold);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        /* Dropdown Styling */
        select {
            width: 100%;
            padding: 10px;
            border-radius: var(--border-radius-soft);
            border: 1px solid #ddd;
            background-color: var(--warm-white);
            appearance: none; /* Remove default arrow */
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23B8860B%22%20d%3D%22M287%2C197.398L146.203%2C56.591L5.405%2C197.398c-3.612%2C3.612-9.45%2C3.612-13.062%2C0c-3.612-3.612-3.612-9.45%2C0-13.062L140%2C43.535c3.612-3.612%2C9.45-3.612%2C13.062%2C0l133.062%2C133.061C290.612%2C187.948%2C290.612%2C193.786%2C287%2C197.398z%22%2F%3E%3C%2Fsvg%3E'); /* Custom arrow */
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            cursor: pointer;
            font-family: 'Lora', serif; /* Apply Lora font */
            color: var(--dark-text);
        }

        /* Loading Overlay Styling */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999; /* Highest z-index */
            transition: opacity 0.5s ease-out;
            opacity: 0; /* Initially hidden */
            visibility: hidden;
        }

        #loadingOverlay.active {
            opacity: 1;
            visibility: visible;
        }

        #loadingSpinnerImage {
            width: 100px; /* Fixed width */
            height: 100px; /* Fixed height */
            object-fit: contain; /* Ensure it doesn't stretch */
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loadingMessage {
            margin-top: 20px;
            font-size: 1.2em;
            color: var(--primary-gold);
            font-weight: bold;
            opacity: 0; /* Initially hidden for fade-in */
            animation: fadeInOut 2s ease-in-out infinite alternate;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Modal Overlay Styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Default for modals */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #alertModal {
            z-index: 2001; /* Higher than other modals */
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--warm-white);
            padding: 30px;
            border-radius: var(--border-radius-soft);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            position: relative;
            text-align: center;
            animation: modalRise 0.3s ease-out forwards;
            color: var(--dark-text);
        }

        @keyframes modalRise {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h3 {
            font-family: 'Playfair Display', serif;
            color: var(--primary-gold);
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .modal-content p {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .close-modal-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--dark-text);
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close-modal-btn:hover {
            color: var(--primary-gold);
        }

        /* Specific Modal Styles for Photo Source and Caption Buttons */
        #photoSourceModalButtons,
        #captionCustomizationModal .modal-buttons {
            display: flex;
            flex-direction: column; /* Default to column for portrait */
            align-items: center; /* Center items in column */
            gap: 15px; /* Adjust gap for vertical stacking */
            width: 100%;
            max-width: 320px; /* Constrain width of the button group */
            margin: 20px auto 0 auto;
        }

        /* Caption Customization Modal Specifics */
        #captionCustomizationModal .input-field {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius-soft);
            box-sizing: border-box;
            font-family: 'Lora', serif; /* Apply Lora font */
            color: var(--dark-text);
            display: block; /* Ensure inputs take full width */
            margin-left: auto; /* Center input field */
            margin-right: auto; /* Center input field */
            max-width: 400px; /* Limit width */
        }

        #generatedCaptionDisplay {
            background-color: var(--soft-cream);
            border: 1px dashed var(--primary-gold);
            padding: 15px;
            margin-top: 20px;
            border-radius: var(--border-radius-soft);
            min-height: 50px;
            max-height: 180px; /* Make scrollable */
            overflow-y: auto; /* Enable vertical scrolling */
            text-align: left;
            white-space: pre-wrap; /* Preserve line breaks */
            word-wrap: break-word; /* Break long words */
            font-family: 'Lora', serif;
            color: var(--dark-text);
            margin-left: auto; /* Center the display box */
            margin-right: auto; /* Center the display box */
            max-width: 400px; /* Match input field width */
        }

        /* camera specific styles */
        .camera-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            margin-top: 20px;
        }
        .camera-section video {
            width: 100%;
            max-width: 400px; /* Max width for camera video */
            height: auto;
            background-color: #000;
            border-radius: 10px;
            display: block;
            transform-origin: center center;
        }
        .camera-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }
        /* Camera control buttons now use the global .action-button styles for consistency */

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .header-content {
                margin-bottom: 15px;
            }

            .logo-image {
                max-width: 280px;
            }

            .container {
                padding: 20px;
                gap: 20px;
                width: calc(100% - 30px); /* Adjust for smaller screens based on body padding */
            }

            .main-content-area {
                flex-direction: column; /* Stack vertically on smaller screens */
                align-items: center;
                gap: 20px;
            }

            .canvas-container {
                width: 100%; /* Full width for canvas container */
                align-items: center;
                padding: 5px; /* Reduce padding on smaller screens */
            }

            #imageCanvas {
                width: 100%; /* Make canvas responsive */
                max-width: 400px; /* Limit max size on tablets */
                height: auto;
            }

            .controls-container {
                max-width: none; /* Remove max-width on smaller screens */
                width: 100%; /* Full width for controls */
                padding: 15px;
                gap: 15px;
            }

            .tab-button {
                padding: 8px 10px;
                font-size: 0.9em;
            }

            /* Landscape (default) for smaller screens */
            .control-buttons-group {
                min-width: unset; /* Remove min-width to allow more flexibility */
                flex-basis: 48%; /* Adjust for 2 buttons per row */
            }
            /* Ensure Horizontal and Vertical flip fit on one row in landscape */
            .control-group:nth-of-type(3) .control-buttons-group .control-sub-button {
                flex-basis: 48%; /* Ensure they fit side-by-side */
            }


            .modal-content {
                padding: 25px;
                width: 95%;
            }

            .modal-content h3 {
                font-size: 1.5em;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .logo-image {
                max-width: 220px;
            }

            .container {
                padding: 15px;
                gap: 15px;
            }

            .action-button {
                padding: 10px 15px;
                font-size: 0.9em;
            }

            .control-sub-button {
                min-width: 100%; /* Stack buttons on very small screens */
            }

            .modal-content {
                padding: 20px;
            }

            .modal-content h3 {
                font-size: 1.3em;
            }
        }

        /* Portrait Mode Specific Styles */
        /* Hide landscape controls in portrait */
        @media (orientation: portrait) {
            .landscape-controls {
                display: none;
            }

            .portrait-controls {
                display: flex;
                flex-direction: column; /* Stack labels row and buttons row */
                align-items: center;
                gap: 10px;
                width: 100%;
            }
            .portrait-labels-row { /* New container for labels */
                display: flex;
                justify-content: space-around; /* Distribute labels evenly */
                width: 100%;
                margin-bottom: 5px; /* Space between labels and buttons */
            }
            .portrait-labels-row label {
                font-weight: bold;
                color: var(--primary-gold);
                font-size: 0.9em;
                text-transform: uppercase;
                flex: 1; /* Distribute space evenly */
                text-align: center; /* Center each label */
            }
            .portrait-buttons-strip {
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap; /* Force single line */
                justify-content: space-around; /* Distribute buttons evenly */
                width: 100%;
                gap: 5px; /* Gap between all 6 buttons */
            }
            .portrait-buttons-strip .control-sub-button {
                flex-direction: column; /* Icon only */
                padding: 8px; /* Slightly more padding for touch targets */
                min-width: unset;
                width: auto;
                font-size: 1.2em; /* Larger icon */
                gap: 0; /* No gap as text is hidden */
                flex-grow: 1; /* Distribute space evenly */
                flex-shrink: 1;
            }
            .portrait-buttons-strip .control-sub-button span.button-text {
                display: none; /* Hide text */
            }

            /* Action buttons (Download/Add Caption) in portrait */
            .action-buttons {
                flex-direction: column; /* Stack vertically */
                gap: 15px; /* Space between stacked buttons */
                align-items: center; /* Center buttons */
                width: 100%; /* Ensure the container takes full width */
            }
            .action-buttons .action-button {
                width: 100%; /* Extend to full width of parent */
                max-width: 280px; /* Constrain max width for aesthetics */
            }
        }

        /* Global styling for action-buttons container (Download/Add Caption buttons) */
        .action-buttons {
            display: flex;
            justify-content: center; /* Centers the buttons horizontally */
            gap: 15px; /* Default space between buttons */
            width: 100%; /* Takes full width of its parent */
            flex-wrap: wrap; /* Allows buttons to wrap to the next line on smaller screens */
        }

        /* Specific landscape adjustments for action-buttons to keep them near each other and match modal buttons */
        @media (orientation: landscape) {
            .portrait-controls {
                display: none;
            }
            .landscape-controls {
                display: flex;
                flex-direction: column; /* Ensure control groups stack vertically */
                gap: 20px; /* Add some spacing between control groups */
            }
            .landscape-controls .control-buttons-group {
                flex-wrap: nowrap; /* Prevent wrapping in landscape */
                justify-content: center; /* Center buttons within their group */
            }
            .landscape-controls .control-buttons-group .control-sub-button {
                flex: 1 1 calc(50% - 5px); /* Ensure two buttons per row, accounting for gap */
                max-width: calc(50% - 5px); /* Ensure they don't grow too large */
            }

            /* Modal buttons in landscape */
            #photoSourceModalButtons,
            #captionCustomizationModal .modal-buttons {
                flex-direction: row; /* Horizontal for landscape */
                flex-wrap: nowrap;
                justify-content: center; /* Center horizontally */
                max-width: 600px; /* Allow wider for two buttons */
                gap: 10px; /* Smaller gap for close proximity */
            }
            #photoSourceModalButtons .action-button,
            #captionCustomizationModal .modal-buttons .action-button {
                flex: 1 1 auto; /* Allow growth */
                max-width: 280px; /* Max width for individual button */
            }

            /* Action buttons (Download/Add Caption) in landscape - now matching modal buttons */
            .action-buttons {
                flex-direction: row; /* Side by side */
                justify-content: center; /* Center the group */
                width: fit-content; /* Shrink-wrap the content */
                margin: 0 auto; /* Center the container itself */
                flex-wrap: nowrap; /* Prevent wrapping in landscape */
                gap: 10px; /* Match modal button gap */
            }
            .action-buttons .action-button { /* Apply flex properties to individual buttons within this container */
                flex-grow: 0; /* Prevent excessive growth */
                flex-shrink: 0; /* Prevent excessive shrinking */
                width: auto; /* Allow width to be determined by content and max-width */
                max-width: 280px; /* Keep consistent max width, matching modal buttons */
            }
        }

        /* Countdown Timer Specific Styles */
        .countdown-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: var(--border-radius-soft);
            padding: 30px;
            box-shadow: 0 8px 20px var(--shadow-medium);
            transition: opacity 1s ease;
            opacity: 1;
            margin-top: 25px; /* Added margin to separate from action buttons */
            width: 100%; /* Ensure it takes full width of the main container */
            max-width: 600px; /* Limit max width for aesthetics */
        }

        .countdown-container.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .countdown-container h1 {
            font-family: 'Playfair Display', serif;
            font-size: 28px;
            color: var(--primary-gold);
            margin-bottom: 20px;
        }

        .countdown {
            display: flex;
            gap: 15px; /* Default gap */
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* Allow time boxes to wrap to next line */
        }

        .time-box {
            background: var(--light-gold);
            color: var(--light-text);
            border-radius: var(--border-radius-soft);
            padding: 15px 10px;
            box-shadow: 0 0 10px var(--shadow-strong);
            text-align: center;
            min-width: 60px;
            flex: 1 1 auto; /* Allows boxes to grow and shrink */
            max-width: 90px; /* Limits maximum size */
        }

        .time-box .value {
            font-size: 36px;
            font-family: 'Playfair Display', serif;
            font-weight: bold;
        }

        .time-box .label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        /* Responsive adjustments for countdown timer */
        @media (max-width: 480px) {
            .countdown-container h1 {
                font-size: 24px;
            }
            .countdown {
                gap: 10px; /* Reduced gap on smaller screens */
            }
            .time-box {
                min-width: 50px;
                padding: 12px 8px;
            }
            .time-box .value {
                font-size: 30px; /* Smaller font size for values */
            }
            .time-box .label {
                font-size: 10px; /* Smaller font size for labels */
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="modal-overlay">
        <div class="modal-content" style="max-width: 300px; padding: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center;">
            <img id="loadingSpinnerImage" src="Key.png" alt="Loading Spinner">
            <div id="loadingMessage">Loading...</div>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alertModal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-modal-btn" id="alertModalCloseBtn"><i class="fas fa-times"></i></button>
            <h3 id="alertModalTitle"></h3>
            <p id="alertModalMessage"></p>
            <div class="modal-buttons">
                <button class="action-button" id="alertModalOkBtn">OKAY</button>
            </div>
        </div>
    </div>

    <div class="header-content">
        <img src="Logo.png" alt="Secret Garden" class="logo-image">
    </div>

    <div class="container">
        <!-- Add Photo to Frame Section -->
        <div class="add-photo-container">
            <div class="file-input-wrapper action-button" id="imageUploadTrigger">
                CHOOSE PHOTO
                <input type="file" id="selectGalleryInput" accept="image/*">
            </div>
        </div>

        <div class="main-content-area">
            <div class="canvas-container">
                <canvas id="imageCanvas"></canvas>
                <div class="facebook-toggle-container">
                    <label for="facebookProfileSwitch">FACEBOOK PROFILE VIEW</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="facebookProfileSwitch">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>

            <div class="controls-container">
                <div class="tabs-header">
                    <button class="tab-button active" id="scalePositionTabBtn">SCALE AND POSITION</button>
                    <button class="tab-button" id="imageAdjustmentsTabBtn">IMAGE ADJUSTMENTS</button>
                </div>

                <div id="scalePositionTab" class="tab-content active">
                    <!-- Landscape Controls (default, hidden in portrait) -->
                    <div class="landscape-controls">
                        <div class="control-group">
                            <label><i class="fas fa-search-plus"></i> ZOOM</label>
                            <div class="control-buttons-group">
                                <button class="control-sub-button" id="zoomInBtn"><i class="fas fa-plus"></i> <span class="button-text">In</span></button>
                                <button class="control-sub-button" id="zoomOutBtn"><i class="fas fa-minus"></i> <span class="button-text">Out</span></button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label><i class="fas fa-redo-alt"></i> ROTATE</label>
                            <div class="control-buttons-group">
                                <button class="control-sub-button" id="rotateLeftBtn"><i class="fas fa-undo"></i> <span class="button-text">Left</span></button>
                                <button class="control-sub-button" id="rotateRightBtn"><i class="fas fa-redo"></i> <span class="button-text">Right</span></button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label><i class="fas fa-arrows-alt-h"></i> FLIP</label>
                            <div class="control-buttons-group">
                                <button class="control-sub-button" id="flipHorizontalBtn"><i class="fas fa-arrows-alt-h"></i> <span class="button-text">Horizontal</span></button>
                                <button class="control-sub-button" id="flipVerticalBtn"><i class="fas fa-arrows-alt-v"></i> <span class="button-text">Vertical</span></button>
                            </div>
                        </div>
                    </div>

                    <!-- Portrait Controls (hidden in landscape) -->
                    <div class="portrait-controls">
                        <div class="portrait-labels-row">
                            <label>ZOOM</label>
                            <label>ROTATE</label>
                            <label>FLIP</label>
                        </div>
                        <div class="portrait-buttons-strip">
                            <button class="control-sub-button" id="zoomInBtnPortrait"><i class="fas fa-plus"></i></button>
                            <button class="control-sub-button" id="zoomOutBtnPortrait"><i class="fas fa-minus"></i></button>
                            <button class="control-sub-button" id="rotateLeftBtnPortrait"><i class="fas fa-undo"></i></button>
                            <button class="control-sub-button" id="rotateRightBtnPortrait"><i class="fas fa-redo"></i></button>
                            <button class="control-sub-button" id="flipHorizontalBtnPortrait"><i class="fas fa-arrows-alt-h"></i></button>
                            <button class="control-sub-button" id="flipVerticalBtnPortrait"><i class="fas fa-arrows-alt-v"></i></button>
                        </div>
                    </div>

                    <button class="action-button" id="revertPhotoBtn">RESET</button>
                </div>

                <!-- Replaced Filter Controls -->
                <div id="imageAdjustmentsTab" class="tab-content">
                    <div class="control-group">
                        <div class="slider-group">
                            <label for="filterSelect"><i class="fas fa-palette"></i> Select Adjustment:</label>
                            <select id="filterSelect" class="w-full p-2 border rounded-lg mb-4" style="background-color: var(--warm-white); color: var(--dark-text); border-color: var(--light-gold);">
                                <option value="brightness">Brightness</option>
                                <option value="contrast">Contrast</option>
                                <option value="saturation">Saturation</option>
                            </select>

                            <label for="filterSlider"><i class="fas fa-sliders-h"></i> <span id="filterLabel">Brightness</span>: <span id="filterValue">100%</span></label>
                            <input type="range" id="filterSlider" min="0" max="200" value="100">
                        </div>
                        <button id="revertFiltersBtn" class="action-button mt-4">RESET</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="action-buttons">
            <!-- Order changed: Download button on the left -->
            <button class="action-button" id="downloadBtn">DOWNLOAD IMAGE</button>
            <button class="action-button" id="finalizeBtn">ADD CAPTION</button>
        </div>

        <!-- Countdown Timer Section -->
        <div class="countdown-container">
            <h1>Get ready! DP Blast starts in...</h1>
            <div class="countdown">
                <div class="time-box">
                    <div class="value" id="days">00</div>
                    <div class="label">Days</div>
                </div>
                <div class="time-box">
                    <div class="value" id="hours">00</div>
                    <div class="label">Hours</div>
                </div>
                <div class="time-box">
                    <div class="value" id="minutes">00</div>
                    <div class="label">Minutes</div>
                </div>
                <div class="time-box">
                    <div class="value" id="seconds">00</div>
                    <div class="label">Seconds</div>
                </div>
            </div>
        </div>
        <!-- End Countdown Timer Section -->

    </div>

    <!-- Hidden Canvas for final output -->
    <canvas id="hiddenCanvas" style="display:none;"></canvas>

    <!-- Hidden Image Elements -->
    <img id="frameImage" src="Frame.png" style="display:none;">
    <img id="defaultImage" src="DefaultImage.png" style="display:none;">
    <img id="facebookViewImage" src="Facebook_View.png" style="display:none;">


    <!-- Modals -->
    <!-- Photo Source Modal -->
    <div id="photoSourceModal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-modal-btn" id="photoSourceModalCloseBtn"><i class="fas fa-times"></i></button>
            <!-- New div to control visibility of initial photo source selection -->
            <div id="photoSourceSelectionControls">
                <h3>CHOOSE YOUR PHOTO SOURCE</h3>
                <p>Select whether you'd like to upload a photo from your gallery or take one using your camera.</p>
                <div class="modal-buttons" id="photoSourceModalButtons">
                    <button class="action-button" id="selectGalleryBtn">
                        <i class="fas fa-image"></i> GALLERY
                    </button>
                    <button class="action-button" id="useCameraBtn">
                        <i class="fas fa-camera"></i> CAMERA
                    </button>
                </div>
            </div>

            <!-- Camera Options Section (initially hidden) -->
            <div id="cameraOptionsSection" class="camera-section hidden">
                <h3 style="color: var(--primary-gold); margin-top: 20px;">CAMERA PREVIEW</h3>
                <video id="cameraVideo" autoplay playsinline muted></video>
                <div class="camera-controls">
                    <button class="action-button" id="captureCameraPhotoBtn"><i class="fas fa-camera-retro"></i> CAPTURE</button>
                    <button class="action-button" id="flipCameraPreviewBtn"><i class="fas fa-arrows-rotate"></i> FLIP PREVIEW</button>
                    <button class="action-button" id="switchCameraButton" disabled><i class="fas fa-sync-alt"></i> SWITCH CAMERA</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Caption Customization Modal -->
    <div id="captionCustomizationModal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-modal-btn" id="captionModalCloseBtn"><i class="fas fa-times"></i></button>
            <h3>CUSTOMIZE CAPTION</h3>
            <p>Fill in the details below to generate a personalized caption for your photo!</p>
            <label for="personNameInput" class="block text-left text-sm font-bold text-gray-700 mb-1">Nickname or Name:</label>
            <input type="text" id="personNameInput" class="input-field" placeholder="Nickname or Name (e.g. Juan / Jay)">
            <label for="degreeProgramSelect" class="block text-left text-sm font-bold text-gray-700 mb-1">Degree Program:</label>
            <select id="degreeProgramSelect" class="input-field">
                <option value="">Select Degree Program</option>
                <option value="BS Agriculture">BS Agriculture</option>
                <option value="BS Agricultural Biotechnology">BS Agricultural Biotechnology</option>
                <option value="BS Agricultural Chemistry">BS Agricultural Chemistry</option>
                <option value="BS Food Science and Technology">BS Food Science and Technology</option>
            </select>
            <div id="generatedCaptionDisplay">
                Your generated caption will appear here.
            </div>
            <div class="modal-buttons" id="captionCustomizationModalButtons">
                <button class="action-button" id="generateCaptionBtn">GENERATE CAPTION</button>
                <button class="action-button" id="copyCaptionBtn">COPY TO CLIPBOARD</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables for canvas and image manipulation
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const hiddenCtx = hiddenCanvas.getContext('2d');

        let currentImage = null; // The user's loaded image or the default placeholder
        let frameImage = document.getElementById('frameImage'); // The decorative frame image
        let defaultImage = document.getElementById('defaultImage'); // The initial placeholder image
        let facebookViewImage = document.getElementById('facebookViewImage'); // Facebook overlay image

        let zoomLevel = 1; // Current zoom level of the user image
        let panX = 0;      // Current X-offset for panning
        let panY = 0;      // Current Y-offset for panning
        let isDragging = false; // Flag for mouse/touch dragging
        let lastX, lastY; // Last coordinates for dragging (for mouse)

        // Touch-specific variables
        let isPinching = false;
        let initialPinchDistance = 0;
        let initialZoomLevel = 1;
        let initialPanX = 0;
        let initialPanY = 0;
        let touchStartX, touchStartY; // For single-finger panning

        let rotationAngle = 0; // Current rotation angle in radians
        let flipH = 1;     // Horizontal flip (1 or -1)
        let flipV = 1;     // Vertical flip (1 or -1)

        // New Global Variables for filter values
        let brightness = 100;
        let contrast = 100;
        let saturation = 100;

        let facebookProfileView = false; // Flag for Facebook profile view mode

        // Elements for Loading Overlay
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');

        // Elements for Custom Alert Modal
        const alertModal = document.getElementById('alertModal');
        const alertModalTitle = document.getElementById('alertModalTitle');
        const alertModalMessage = document.getElementById('alertModalMessage');
        const alertModalCloseBtn = document.getElementById('alertModalCloseBtn');
        const alertModalOkBtn = document.getElementById('alertModalOkBtn');

        // Elements for Camera
        const photoSourceSelectionControls = document.getElementById('photoSourceSelectionControls'); // New element
        const cameraOptionsSection = document.getElementById('cameraOptionsSection');
        const cameraVideo = document.getElementById('cameraVideo');
        const captureCameraPhotoBtn = document.getElementById('captureCameraPhotoBtn');
        const flipCameraPreviewBtn = document.getElementById('flipCameraPreviewBtn');
        const switchCameraButton = document.getElementById('switchCameraButton');
        let localStream; // Stores the MediaStream object for the camera
        let cameraDevices = []; // Stores available camera devices
        let cameraCurrentFacingMode = 'user'; // 'user' for front camera, 'environment' for rear
        let cameraPreviewFlip = -1; // -1 for mirror effect (default for user-facing camera), 1 for normal

        // New DOM Elements for filters
        const filterSelect = document.getElementById('filterSelect');
        const filterSlider = document.getElementById('filterSlider');
        const filterLabel = document.getElementById('filterLabel');
        const filterValue = document.getElementById('filterValue');
        const revertFiltersBtn = document.getElementById('revertFiltersBtn'); // New reset button for filters

        // Global animation variables for grid and frame opacity
        let currentGridAlpha = 0; // Starts hidden
        let currentFrameAlpha = 1; // Starts opaque
        let animationFrameId = null;
        let lastAnimateTime = 0;
        const ANIMATION_DURATION = 200; // milliseconds for fade in/out

        // Function to animate alpha values for grid and frame
        function animateAlpha(targetAlphaGrid, targetAlphaFrame) {
            const startTime = performance.now();
            const startGridAlpha = currentGridAlpha;
            const startFrameAlpha = currentFrameAlpha;

            function step(currentTime) {
                if (!lastAnimateTime) lastAnimateTime = currentTime;
                const deltaTime = currentTime - lastAnimateTime;
                lastAnimateTime = currentTime;

                const progress = Math.min(1, (currentTime - startTime) / ANIMATION_DURATION);

                currentGridAlpha = startGridAlpha + (targetAlphaGrid - startGridAlpha) * progress;
                currentFrameAlpha = startFrameAlpha + (targetAlphaFrame - startFrameAlpha) * progress;

                drawImageOnCanvas(); // Redraw with new alphas

                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(step);
                } else {
                    // Ensure final values are set precisely
                    currentGridAlpha = targetAlphaGrid;
                    currentFrameAlpha = targetAlphaFrame;
                    drawImageOnCanvas();
                    animationFrameId = null;
                }
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(step);
        }

        // Function to show loading overlay
        function showLoadingOverlay(message = "LOADING...") {
            loadingMessage.textContent = message;
            loadingOverlay.classList.add('active');
        }

        // Function to hide loading overlay
        function hideLoadingOverlay() {
            loadingOverlay.classList.remove('active');
        }

        // Custom Alert Modal Functions
        function showAlertModal(message, title = "ALERT") {
            alertModalTitle.textContent = title;
            alertModalMessage.textContent = message;
            alertModal.classList.add('active');
        }

        function hideAlertModal() {
            alertModal.classList.remove('active');
        }

        alertModalCloseBtn.addEventListener('click', hideAlertModal);
        alertModalOkBtn.addEventListener('click', hideAlertModal);

        // Function to load an image and set it as currentImage
        function loadImageAndSet(imgSrc, initialFlipH = 1) {
            return new Promise((resolve, reject) => {
                showLoadingOverlay("IMPORTING PICTURE..."); // Updated loading message
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    
                    // Reset transformations to fit the new image
                    zoomLevel = 1;
                    panX = 0;
                    panY = 0;
                    rotationAngle = 0;
                    flipH = initialFlipH; // Apply initial flip from camera if needed
                    flipV = 1;

                    // Calculate initial zoom and pan to fit the image within the frame area
                    const canvasAspectRatio = imageCanvas.width / imageCanvas.height;
                    const imageAspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;

                    if (imageAspectRatio > canvasAspectRatio) {
                        // Image is wider than canvas, fit by height
                        zoomLevel = imageCanvas.height / currentImage.naturalHeight;
                    } else {
                        // Image is taller than canvas, fit by width
                        zoomLevel = imageCanvas.width / currentImage.naturalWidth;
                    }
                    
                    // Center the image initially
                    panX = (imageCanvas.width - (currentImage.naturalWidth * zoomLevel)) / 2;
                    panY = (imageCanvas.height - (currentImage.naturalHeight * zoomLevel)) / 2;

                    drawImageOnCanvas();
                    hideLoadingOverlay();
                    toggleControls(true); // Enable controls after image is loaded
                    updateFilterSliderUI(); // Initialize filter UI with default/current values
                    resolve();
                };
                img.onerror = (error) => {
                    console.error("Error loading image:", error);
                    hideLoadingOverlay();
                    showAlertModal("FAILED TO LOAD IMAGE. PLEASE TRY ANOTHER FILE OR CHECK THE IMAGE SOURCE.");
                    reject(error);
                };
                img.src = imgSrc;
            });
        }

        // Function to draw grid overlay
        function drawGrid(targetCtx, canvasWidth, canvasHeight) {
            targetCtx.save();
            targetCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            targetCtx.lineWidth = 1;

            // Vertical lines
            targetCtx.beginPath();
            targetCtx.moveTo(canvasWidth / 3, 0);
            targetCtx.lineTo(canvasWidth / 3, canvasHeight);
            targetCtx.moveTo(canvasWidth * 2 / 3, 0);
            targetCtx.lineTo(canvasWidth * 2 / 3, canvasHeight);
            targetCtx.stroke();

            // Horizontal lines
            targetCtx.beginPath();
            targetCtx.moveTo(0, canvasHeight / 3);
            targetCtx.lineTo(canvasWidth, canvasHeight / 3);
            targetCtx.moveTo(0, canvasHeight * 2 / 3);
            targetCtx.lineTo(canvasWidth, canvasHeight * 2 / 3);
            targetCtx.stroke();

            targetCtx.restore();
        }

        // Main drawing function for the preview canvas
        function drawImageOnCanvas() {
            if (!frameImage) return; // Ensure frame is loaded

            // Canvas dimensions always based on the frame's natural aspect ratio
            // and a fixed base width for preview
            const baseCanvasWidth = 500;
            const baseCanvasHeight = baseCanvasWidth * (frameImage.naturalHeight / frameImage.naturalWidth);

            imageCanvas.width = baseCanvasWidth;
            imageCanvas.height = baseCanvasHeight;
            hiddenCanvas.width = baseCanvasWidth;
            hiddenCanvas.height = baseCanvasHeight; // Ensure hidden canvas matches

            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);

            // 1. Draw blurred background if an image is loaded
            if (currentImage) {
                ctx.save();
                ctx.filter = 'blur(10px)'; // Apply blur to background

                // Apply flip to the blurred background
                ctx.translate(imageCanvas.width / 2, imageCanvas.height / 2); // Translate to center for scaling
                ctx.scale(flipH, flipV);
                ctx.translate(-imageCanvas.width / 2, -imageCanvas.height / 2); // Translate back

                // Draw currentImage scaled to fill the entire canvas for the background blur
                const bgAspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
                let bgDrawWidth, bgDrawHeight, bgDrawX, bgDrawY;

                if (bgAspectRatio > imageCanvas.width / imageCanvas.height) {
                    bgDrawHeight = imageCanvas.height;
                    bgDrawWidth = imageCanvas.height * bgAspectRatio;
                } else {
                    bgDrawWidth = imageCanvas.width;
                    bgDrawHeight = imageCanvas.width / bgAspectRatio;
                }
                bgDrawX = (imageCanvas.width - bgDrawWidth) / 2;
                bgDrawY = (imageCanvas.height - bgDrawHeight) / 2;
                ctx.drawImage(currentImage, bgDrawX, bgDrawY, bgDrawWidth, bgDrawHeight);
                ctx.restore();
            }

            // 2. Draw the main user image (or placeholder) with transformations and filters
            if (currentImage && currentImage !== defaultImage) { // Only apply transforms/filters if not default image
                ctx.save();
                
                // Apply combined filters to the main image
                ctx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;

                // Calculate image dimensions based on original size and zoom
                let imgDisplayWidth = currentImage.naturalWidth * zoomLevel;
                let imgDisplayHeight = currentImage.naturalHeight * zoomLevel;

                // Translate to the center of the image for rotation and flip
                ctx.translate(panX + imgDisplayWidth / 2, panY + imgDisplayHeight / 2);

                if (rotationAngle !== 0) {
                    ctx.rotate(rotationAngle);
                }

                // Apply flip transformations
                ctx.scale(flipH, flipV);

                // Draw the image
                ctx.drawImage(currentImage, -imgDisplayWidth / 2, -imgDisplayHeight / 2, imgDisplayWidth, imgDisplayHeight);
                ctx.restore();
                ctx.filter = 'none'; // Reset filter for subsequent draws
            } else {
                // If no user image or it's the default placeholder, draw it centered
                const defaultImageAspectRatio = defaultImage.naturalWidth / defaultImage.naturalHeight;
                let drawWidth, drawHeight, drawX, drawY;

                // Scale default image to fit within the canvas while maintaining aspect ratio
                if (defaultImageAspectRatio > imageCanvas.width / imageCanvas.height) {
                    // Default image is wider than canvas, fit by width
                    drawWidth = imageCanvas.width;
                    drawHeight = imageCanvas.width / defaultImageAspectRatio;
                } else {
                    // Default image is taller than canvas, fit by height
                    drawHeight = imageCanvas.height;
                    drawWidth = imageCanvas.height * defaultImageAspectRatio;
                }
                
                // Center the default image
                drawX = (imageCanvas.width - drawWidth) / 2;
                drawY = (imageCanvas.height - drawHeight) / 2;

                ctx.drawImage(defaultImage, drawX, drawY, drawWidth, drawHeight);
            }

            // 3. Draw the frame on top with dynamic opacity
            ctx.save();
            ctx.globalAlpha = currentFrameAlpha; // Apply dynamic opacity
            ctx.drawImage(frameImage, 0, 0, imageCanvas.width, imageCanvas.height);
            ctx.restore();

            // 4. Draw Facebook overlay if enabled (only for preview)
            if (facebookProfileView && facebookViewImage.complete) {
                ctx.drawImage(facebookViewImage, 0, 0, imageCanvas.width, imageCanvas.height);
            }

            // 5. Draw grid (always on top for UI guidance) with dynamic opacity
            ctx.save();
            ctx.globalAlpha = currentGridAlpha; // Apply dynamic opacity
            drawGrid(ctx, imageCanvas.width, imageCanvas.height);
            ctx.restore();
        }

        // Function to toggle control buttons and filter options
        function toggleControls(enable) {
            // Landscape controls
            const landscapeControls = [
                document.getElementById('zoomInBtn'),
                document.getElementById('zoomOutBtn'),
                document.getElementById('rotateLeftBtn'),
                document.getElementById('rotateRightBtn'),
                document.getElementById('flipHorizontalBtn'),
                document.getElementById('flipVerticalBtn'),
            ];
            // Portrait controls
            const portraitControls = [
                document.getElementById('zoomInBtnPortrait'),
                document.getElementById('zoomOutBtnPortrait'),
                document.getElementById('rotateLeftBtnPortrait'),
                document.getElementById('rotateRightBtnPortrait'),
                document.getElementById('flipHorizontalBtnPortrait'),
                document.getElementById('flipVerticalBtnPortrait'),
            ];

            const commonControls = [
                document.getElementById('revertPhotoBtn'),
                filterSelect,
                filterSlider,
                revertFiltersBtn,
                document.getElementById('finalizeBtn'),
                document.getElementById('downloadBtn')
            ];

            landscapeControls.forEach(control => { if (control) control.disabled = !enable; });
            portraitControls.forEach(control => { if (control) control.disabled = !enable; });
            commonControls.forEach(control => { if (control) control.disabled = !enable; });

            // Special handling for filter range and display when disabled
            if (!enable) {
                // Reset filter values and UI when controls are disabled (e.g., placeholder image)
                brightness = 100;
                contrast = 100;
                saturation = 100;
                filterSelect.value = 'brightness'; // Reset dropdown to brightness
                filterSlider.value = 100; // Reset slider to 100
                filterLabel.textContent = 'Brightness'; // Reset label
                filterValue.textContent = '100%'; // Reset value display
                ctx.filter = 'none'; // Ensure no filter is applied to placeholder
            }
            drawImageOnCanvas(); // Redraw to reflect disabled state/no filter
        }


        // Initial image and frame loading
        window.onload = async function() {
            console.log("window.onload triggered. Starting initialization...");
            showLoadingOverlay("LOADING ASSETS..."); // Updated loading message

            // Load all necessary images first
            const loadImageElement = (imgElement, fallbackWidth = 500, fallbackHeight = 500, altText = 'IMAGE') => {
                return new Promise((resolve, reject) => {
                    if (imgElement.complete && imgElement.naturalHeight !== 0) {
                        console.log(`Image already loaded: ${imgElement.src.split('/').pop()}`);
                        resolve(); // Image already loaded
                    } else {
                        const originalSrc = imgElement.src;
                        imgElement.onload = () => {
                            console.log(`Successfully loaded image: ${originalSrc.split('/').pop()}`);
                            resolve();
                        };
                        imgElement.onerror = () => {
                            console.error(`Failed to load image: ${originalSrc.split('/').pop()}. Using placeholder.`);
                            showAlertModal(`WARNING: FAILED TO LOAD ${altText} IMAGE FROM ${originalSrc.split('/').pop()}. USING A GENERIC PLACEHOLDER.`);
                            imgElement.src = `https://placehold.co/${fallbackWidth}x${fallbackHeight}/E0E0E0/333333?text=${encodeURIComponent(altText)}`;
                            imgElement.onload = resolve; // Resolve once placeholder loads
                            imgElement.onerror = (e) => { // Fallback for placeholder loading failure
                                console.error(`Failed to load placeholder for ${altText}:`, e);
                                reject(`FAILED TO LOAD PLACEHOLDER FOR ${altText}.`);
                            };
                        };
                    }
                });
            };

            try {
                // Load images with fallbacks
                console.log("Attempting to load all required images...");
                await Promise.all([
                    loadImageElement(document.querySelector('.logo-image'), 350, 100, 'LOGO'),
                    loadImageElement(document.getElementById('loadingSpinnerImage'), 100, 100, 'KEY'), // Loading spinner
                    loadImageElement(frameImage, 500, 500, 'FRAME'),
                    loadImageElement(defaultImage, 500, 500, 'DEFAULT IMAGE'),
                    loadImageElement(facebookViewImage, 500, 500, 'FACEBOOK OVERLAY')
                ]);
                console.log("All required images (or their placeholders) loaded successfully.");
                
                // Set initial image to default placeholder
                currentImage = defaultImage;
                drawImageOnCanvas();
                hideLoadingOverlay();
                toggleControls(false); // Disable controls initially for placeholder
                console.log("Photo Frame initialized successfully.");

                // Initialize countdown timer after all assets are loaded
                countdown(); // Initial call to display countdown immediately
                const timerInterval = setInterval(countdown, 1000); // Start the interval
            } catch (error) {
                console.error("Initialization failed during image loading:", error);
                hideLoadingOverlay();
                showAlertModal("CRITICAL ERROR DURING INITIALIZATION. PLEASE CHECK THE CONSOLE FOR DETAILS.");
            }
        };

        // Canvas interaction: Pan (Mouse)
        imageCanvas.addEventListener('mousedown', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            imageCanvas.classList.add('grabbing');
            animateAlpha(1, 0.5); // Grid fully visible, frame 50% opaque
        });

        imageCanvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            panX += dx;
            panY += dy;
            lastX = e.clientX;
            lastY = e.clientY;
            drawImageOnCanvas();
        });

        imageCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            imageCanvas.classList.remove('grabbing');
            animateAlpha(0, 1); // Grid hidden, frame opaque
        });

        imageCanvas.addEventListener('mouseleave', () => {
            if (isDragging) { // Only fade out if dragging was active and mouse left
                isDragging = false;
                imageCanvas.classList.remove('grabbing');
                animateAlpha(0, 1); // Grid hidden, frame opaque
            }
        });

        // Canvas interaction: Touch (Pan and Pinch-to-Zoom)
        imageCanvas.addEventListener('touchstart', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            e.preventDefault(); // Prevent default touch behaviors like scrolling

            if (e.touches.length === 1) {
                // Single-finger pan
                isDragging = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                imageCanvas.classList.add('grabbing');
                animateAlpha(1, 0.5);
            } else if (e.touches.length === 2) {
                // Two-finger pinch-to-zoom
                isPinching = true;
                initialPinchDistance = getPinchDistance(e.touches);
                initialZoomLevel = zoomLevel;
                initialPanX = panX;
                initialPanY = panY;
                imageCanvas.classList.add('grabbing');
                animateAlpha(1, 0.5);
            }
        });

        imageCanvas.addEventListener('touchmove', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            e.preventDefault(); // Prevent default touch behaviors like scrolling

            if (isPinching && e.touches.length === 2) {
                const currentPinchDistance = getPinchDistance(e.touches);
                const scaleFactor = currentPinchDistance / initialPinchDistance;
                
                // Calculate pinch center relative to the canvas
                const rect = imageCanvas.getBoundingClientRect();
                const touch1X = e.touches[0].clientX - rect.left;
                const touch1Y = e.touches[0].clientY - rect.top;
                const touch2X = e.touches[1].clientX - rect.left;
                const touch2Y = e.touches[1].clientY - rect.top;
                const pinchCenterX = (touch1X + touch2X) / 2;
                const pinchCenterY = (touch1Y + touch2Y) / 2;

                // Apply zoom
                zoomLevel = initialZoomLevel * scaleFactor;
                zoomLevel = Math.max(0.1, Math.min(5, zoomLevel)); // Clamp zoom level

                // Adjust pan to zoom around the pinch center
                panX = pinchCenterX - ((pinchCenterX - initialPanX) * (zoomLevel / initialZoomLevel));
                panY = pinchCenterY - ((pinchCenterY - initialPanY) * (zoomLevel / initialZoomLevel));

            } else if (isDragging && e.touches.length === 1) {
                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                panX += dx;
                panY += dy;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
            drawImageOnCanvas();
        });

        imageCanvas.addEventListener('touchend', (e) => {
            isDragging = false;
            isPinching = false;
            imageCanvas.classList.remove('grabbing');
            animateAlpha(0, 1);
        });

        imageCanvas.addEventListener('touchcancel', (e) => {
            isDragging = false;
            isPinching = false;
            imageCanvas.classList.remove('grabbing');
            animateAlpha(0, 1);
        });

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }


        // Canvas interaction: Zoom with mouse wheel
        let wheelTimeout;
        imageCanvas.addEventListener('wheel', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            e.preventDefault(); // Prevent page scrolling
            
            // Start fade in if not already fading in
            if (currentGridAlpha < 1 || currentFrameAlpha > 0.5) {
                animateAlpha(1, 0.5);
            }

            const scaleAmount = 0.05; // Smaller increment for gentler zoom
            const mouseX = e.clientX - imageCanvas.getBoundingClientRect().left;
            const mouseY = e.clientY - imageCanvas.getBoundingClientRect().top;

            const oldZoomLevel = zoomLevel;

            if (e.deltaY < 0) {
                // Zoom in
                zoomLevel += scaleAmount;
            } else {
                // Zoom out
                zoomLevel = Math.max(0.1, zoomLevel - scaleAmount); // Prevent zooming out too much
            }

            // Adjust pan to zoom towards mouse position
            panX = mouseX - ((mouseX - panX) * (zoomLevel / oldZoomLevel));
            panY = mouseY - ((mouseY - panY) * (zoomLevel / oldZoomLevel));

            drawImageOnCanvas();

            // Clear previous timeout and set a new one to fade out
            clearTimeout(wheelTimeout);
            wheelTimeout = setTimeout(() => {
                animateAlpha(0, 1); // Grid hidden, frame opaque
            }, 500); // Fade out after 500ms of no wheel activity
        });

        // Image Manipulation Buttons
        // Landscape buttons
        document.getElementById('zoomInBtn').addEventListener('click', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            const oldZoomLevel = zoomLevel;
            zoomLevel += 0.1; // Gentle increment
            
            // Zoom towards the center of the canvas
            const canvasCenterX = imageCanvas.width / 2;
            const canvasCenterY = imageCanvas.height / 2;

            panX = canvasCenterX - ((canvasCenterX - panX) * (zoomLevel / oldZoomLevel));
            panY = canvasCenterY - ((canvasCenterY - panY) * (zoomLevel / oldZoomLevel));

            drawImageOnCanvas();
        });

        document.getElementById('zoomOutBtn').addEventListener('click', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            const oldZoomLevel = zoomLevel;
            zoomLevel = Math.max(0.1, zoomLevel - 0.1); // Gentle decrement

            // Zoom towards the center of the canvas
            const canvasCenterX = imageCanvas.width / 2;
            const canvasCenterY = imageCanvas.height / 2;

            panX = canvasCenterX - ((canvasCenterX - panX) * (zoomLevel / oldZoomLevel));
            panY = canvasCenterY - ((canvasCenterY - panY) * (zoomLevel / oldZoomLevel));

            drawImageOnCanvas();
        });

        document.getElementById('rotateLeftBtn').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            rotationAngle -= (Math.PI / 180) * 15; // Rotate by 15 degrees
            drawImageOnCanvas();
        });

        document.getElementById('rotateRightBtn').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            rotationAngle += (Math.PI / 180) * 15; // Rotate by 15 degrees
            drawImageOnCanvas();
        });

        document.getElementById('flipHorizontalBtn').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            flipH *= -1; // Toggle between 1 and -1
            drawImageOnCanvas();
        });

        document.getElementById('flipVerticalBtn').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            flipV *= -1; // Toggle between 1 and -1
            drawImageOnCanvas();
        });

        // Portrait buttons (new event listeners for duplicated elements)
        document.getElementById('zoomInBtnPortrait').addEventListener('click', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            const oldZoomLevel = zoomLevel;
            zoomLevel += 0.1;
            const canvasCenterX = imageCanvas.width / 2;
            const canvasCenterY = imageCanvas.height / 2;
            panX = canvasCenterX - ((canvasCenterX - panX) * (zoomLevel / oldZoomLevel));
            panY = canvasCenterY - ((canvasCenterY - panY) * (zoomLevel / oldZoomLevel));
            drawImageOnCanvas();
        });

        document.getElementById('zoomOutBtnPortrait').addEventListener('click', (e) => {
            if (!currentImage || currentImage === defaultImage) return;
            const oldZoomLevel = zoomLevel;
            zoomLevel = Math.max(0.1, zoomLevel - 0.1);
            const canvasCenterX = imageCanvas.width / 2;
            const canvasCenterY = imageCanvas.height / 2;
            panX = canvasCenterX - ((canvasCenterX - panX) * (zoomLevel / oldZoomLevel));
            panY = canvasCenterY - ((canvasCenterY - panY) * (zoomLevel / oldZoomLevel));
            drawImageOnCanvas();
        });

        document.getElementById('rotateLeftBtnPortrait').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            rotationAngle -= (Math.PI / 180) * 15;
            drawImageOnCanvas();
        });

        document.getElementById('rotateRightBtnPortrait').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            rotationAngle += (Math.PI / 180) * 15;
            drawImageOnCanvas();
        });

        document.getElementById('flipHorizontalBtnPortrait').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            flipH *= -1;
            drawImageOnCanvas();
        });

        document.getElementById('flipVerticalBtnPortrait').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            flipV *= -1;
            drawImageOnCanvas();
        });

        document.getElementById('revertPhotoBtn').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) return;
            // Recalculate initial fit for current image
            const canvasAspectRatio = imageCanvas.width / imageCanvas.height;
            const imageAspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;

            if (imageAspectRatio > canvasAspectRatio) {
                zoomLevel = imageCanvas.height / currentImage.naturalHeight;
            } else {
                zoomLevel = imageCanvas.width / currentImage.naturalWidth;
            }
            panX = (imageCanvas.width - (currentImage.naturalWidth * zoomLevel)) / 2;
            panY = (imageCanvas.height - (currentImage.naturalHeight * zoomLevel)) / 2;
            
            rotationAngle = 0;
            flipH = 1;
            flipV = 1;
            drawImageOnCanvas();
        });

        // New JavaScript function to update filter slider UI
        function updateFilterSliderUI() {
            const selectedFilter = filterSelect.value;
            let currentValue = 100; // Default value

            switch (selectedFilter) {
                case 'brightness':
                    currentValue = brightness;
                    filterLabel.textContent = 'Brightness';
                    break;
                case 'contrast':
                    currentValue = contrast;
                    filterLabel.textContent = 'Contrast';
                    break;
                case 'saturation':
                    currentValue = saturation;
                    filterLabel.textContent = 'Saturation';
                    break;
            }
            filterSlider.value = currentValue;
            filterValue.textContent = `${currentValue}%`;
        }

        // New JavaScript event listeners for filter controls
        filterSelect.addEventListener('change', () => {
            updateFilterSliderUI(); // Update UI to reflect selected filter's stored value
            drawImageOnCanvas(); // Redraw with the new filter
        });

        filterSlider.addEventListener('input', () => {
            const selectedFilter = filterSelect.value;
            const value = parseInt(filterSlider.value);

            switch (selectedFilter) {
                case 'brightness':
                    brightness = value;
                    break;
                case 'contrast':
                    contrast = value;
                    break;
                case 'saturation':
                    saturation = value;
                    break;
            }
            filterValue.textContent = `${value}%`;
            drawImageOnCanvas(); // Redraw the image with new filter
        });

        // Event listener for the "Reset Filters" button
        revertFiltersBtn.addEventListener('click', () => {
            if (currentImage !== defaultImage) {
                brightness = 100;
                contrast = 100;
                saturation = 100;
                filterSelect.value = 'brightness'; // Reset dropdown to brightness
                filterSlider.value = 100; // Reset slider to 100
                updateFilterSliderUI(); // Update UI to reflect reset
                drawImageOnCanvas(); // Redraw the image with reset filters
            }
        });

        // Facebook Profile View Toggle
        const facebookProfileSwitch = document.getElementById('facebookProfileSwitch');
        facebookProfileSwitch.addEventListener('change', () => {
            facebookProfileView = facebookProfileSwitch.checked;
            drawImageOnCanvas(); // Redraw canvas with new dimensions and overlay
        });

        // Tab Switching
        const scalePositionTabBtn = document.getElementById('scalePositionTabBtn');
        const imageAdjustmentsTabBtn = document.getElementById('imageAdjustmentsTabBtn');
        const scalePositionTab = document.getElementById('scalePositionTab');
        const imageAdjustmentsTab = document.getElementById('imageAdjustmentsTab');

        function showTab(tabId) {
            // Hide all tab content
            scalePositionTab.classList.remove('active');
            imageAdjustmentsTab.classList.remove('active');

            // Deactivate all tab buttons
            scalePositionTabBtn.classList.remove('active');
            imageAdjustmentsTabBtn.classList.remove('active');

            // Show the selected tab content and activate its button
            if (tabId === 'scalePositionTab') {
                scalePositionTab.classList.add('active');
                scalePositionTabBtn.classList.add('active');
            } else if (tabId === 'imageAdjustmentsTab') {
                imageAdjustmentsTab.classList.add('active');
                imageAdjustmentsTabBtn.classList.add('active');
            }
        }

        scalePositionTabBtn.addEventListener('click', () => showTab('scalePositionTab'));
        imageAdjustmentsTabBtn.addEventListener('click', () => showTab('imageAdjustmentsTab'));

        // Modals

        // Photo Source Modal
        const photoSourceModal = document.getElementById('photoSourceModal');
        const photoSourceModalCloseBtn = document.getElementById('photoSourceModalCloseBtn');
        const selectGalleryBtn = document.getElementById('selectGalleryBtn');
        const useCameraBtn = document.getElementById('useCameraBtn');

        function showPhotoSourceModal() {
            photoSourceModal.classList.add('active');
            cameraOptionsSection.classList.add('hidden'); // Hide camera section initially
            photoSourceSelectionControls.classList.remove('hidden'); // Ensure selection controls are visible
            stopCamera(); // Ensure camera is stopped when modal opens
        }

        function hidePhotoSourceModal() {
            photoSourceModal.classList.remove('active');
            stopCamera(); // Stop camera when modal is closed
        }

        photoSourceModalCloseBtn.addEventListener('click', hidePhotoSourceModal);
        selectGalleryBtn.addEventListener('click', () => {
            document.getElementById('selectGalleryInput').click(); // Trigger file input click
            hidePhotoSourceModal(); // Hide the modal after choosing gallery
        });

        // Camera functionality
        useCameraBtn.addEventListener('click', async () => {
            photoSourceSelectionControls.classList.add('hidden'); // Hide the photo source selection
            cameraOptionsSection.classList.remove('hidden'); // Show camera section
            await requestCameraPermissionAndPlay();
        });

        async function requestCameraPermissionAndPlay() {
            // Stop any existing stream before requesting a new one
            stopCamera(); 

            try {
                const constraints = { 
                    audio: false, 
                    video: {
                        width: { ideal: 1280 }, // Request a reasonable resolution
                        height: { ideal: 720 },
                        facingMode: cameraCurrentFacingMode
                    } 
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraVideo.srcObject = localStream;
                cameraVideo.play();
                applyCameraTransforms();
                setCameraControlButtonsState(true);
                await loadCameraDevices();
            } catch (err) {
                console.error('GETUSERMEDIAERROR', err);
                let errorMessage = "COULD NOT START CAMERA. PLEASE ENSURE A CAMERA IS CONNECTED AND PERMISSIONS ARE GRANTED.";
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    errorMessage = "CAMERA ACCESS WAS DENIED. PLEASE ALLOW CAMERA PERMISSIONS IN YOUR BROWSER SETTINGS TO USE THIS FEATURE.";
                } else if (err.name === 'NotFoundError') {
                    errorMessage = "NO CAMERA FOUND. PLEASE ENSURE A CAMERA IS CONNECTED AND ENABLED.";
                } else if (err.name === 'NotReadableError') {
                    errorMessage = "CAMERA IS ALREADY IN USE BY ANOTHER APPLICATION OR BROWSER TAB. PLEASE CLOSE OTHER APPLICATIONS AND TRY AGAIN.";
                }
                showAlertModal(errorMessage, "CAMERA ERROR"); // Use custom alert
                setCameraControlButtonsState(false);
                cameraOptionsSection.classList.add('hidden'); // Hide camera section on error
                photoSourceSelectionControls.classList.remove('hidden'); // Show selection controls again
            }
        }

        async function loadCameraDevices() {
            cameraDevices = [];
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                for (let i = 0; i < devices.length; i++) {
                    let device = devices[i];
                    if (device.kind === 'videoinput') {
                        cameraDevices.push(device);
                    }
                }
                // Only enable switchCameraButton if multiple cameras are detected
                switchCameraButton.disabled = !(cameraDevices.length > 1);
            } catch (e) {
                console.error("ERROR ENUMERATING DEVICES:", e);
            }
        }

        function applyCameraTransforms() {
            let transformString = '';
            // Apply flip to the camera preview video element
            if (cameraPreviewFlip === -1) {
                transformString += `scaleX(-1) `;
            }
            cameraVideo.style.transform = transformString.trim();
        }

        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                });
                localStream = null;
            }
            cameraVideo.srcObject = null;
            cameraVideo.pause();
            cameraVideo.currentTime = 0;
            setCameraControlButtonsState(false);
            cameraPreviewFlip = -1; // Reset flip to mirror mode for next session
            applyCameraTransforms(); // Clear any transforms on video element
        }

        function setCameraControlButtonsState(enabled) {
            captureCameraPhotoBtn.disabled = !enabled;
            flipCameraPreviewBtn.disabled = !enabled;
            // Only enable switchCameraButton if multiple cameras are detected AND camera is enabled
            switchCameraButton.disabled = !(enabled && cameraDevices.length > 1);
        }

        captureCameraPhotoBtn.addEventListener('click', async () => {
            if (!cameraVideo.srcObject) {
                showAlertModal("NO VIDEO STREAM TO CAPTURE FROM. PLEASE START THE CAMERA.", "CAPTURE ERROR");
                return;
            }

            // Show loading animation on button and pause video
            captureCameraPhotoBtn.disabled = true;
            captureCameraPhotoBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> CAPTURING...';
            cameraVideo.pause(); // Stop video motion

            showLoadingOverlay("CAPTURING PHOTO...");

            // Create a temporary canvas to draw the camera frame
            const tempCameraCanvas = document.createElement('canvas');
            const tempCameraCtx = tempCameraCanvas.getContext('2d');

            // Set canvas dimensions to match the video's intrinsic resolution for high quality capture
            tempCameraCanvas.width = cameraVideo.videoWidth;
            tempCameraCanvas.height = cameraVideo.videoHeight;

            // Draw the video frame to the temporary canvas
            tempCameraCtx.save();
            // Apply flip to the captured image if cameraPreviewFlip === -1
            if (cameraPreviewFlip === -1) {
                tempCameraCtx.translate(tempCameraCanvas.width, 0);
                tempCameraCtx.scale(-1, 1);
            }
            tempCameraCtx.drawImage(cameraVideo, 0, 0, tempCameraCanvas.width, tempCameraCanvas.height);
            tempCameraCtx.restore();

            const imgSrc = tempCameraCanvas.toDataURL("image/png");
            
            await loadImageAndSet(imgSrc); // Load the captured image onto the main canvas
            hidePhotoSourceModal(); // Hide the photo source modal
            hideLoadingOverlay();

            // Reset capture button state and restart video
            captureCameraPhotoBtn.disabled = false;
            captureCameraPhotoBtn.innerHTML = '<i class="fas fa-camera-retro"></i> CAPTURE';
            cameraVideo.play(); // Resume video motion
        });

        flipCameraPreviewBtn.addEventListener('click', () => {
            cameraPreviewFlip *= -1; // Toggle horizontal flip for live video preview
            applyCameraTransforms(); // Apply the new flip to the video element
        });

        switchCameraButton.addEventListener('click', async () => {
            // Toggle facing mode ('user' for front, 'environment' for rear)
            cameraCurrentFacingMode = (cameraCurrentFacingMode === 'user') ? 'environment' : 'user';
            cameraPreviewFlip = -1; // Reset live video flip to mirror mode when switching cameras, as orientation might change
            await requestCameraPermissionAndPlay(); // Restart camera with new facing mode
        });


        // Caption Customization Modal
        const captionCustomizationModal = document.getElementById('captionCustomizationModal');
        const captionModalCloseBtn = document.getElementById('captionModalCloseBtn');
        const personNameInput = document.getElementById('personNameInput');
        const degreeProgramSelect = document.getElementById('degreeProgramSelect'); // New dropdown
        const generatedCaptionDisplay = document.getElementById('generatedCaptionDisplay');
        const generateCaptionBtn = document.getElementById('generateCaptionBtn');
        const copyCaptionBtn = document.getElementById('copyCaptionBtn');


        let generatedCaption = ""; // Variable to store the generated caption

        // Hardcoded caption template based on Caption.txt
        const captionTemplate = `     ,        

The enchanted gate has finally opened! I am [nickname], from [degree program] of College of Agriculture and Food Science, a proud ready to take root, bloom with purpose, and grow through the journey ahead! 

As we step into this new journey, let our presence be known       . This moment marks our first bloom in a place where roots run deep and stories unfold like petals under the sun.

In this enchanted space where curiosity grows wild and purpose takes root, we are more than just a student. We are the new bearer of light, learning, and legacy. A quiet magic lives in every scholar who chooses to grow. 

We are called to bloom not only for ourselves but for the land and the people we serve. In this hidden garden of learning and purpose, each seedling is nurtured by knowledge, rooted in service, and destined to bloom with , ,  .

We are  of promise.
We are the  of hope.
We are the new   , ready to root in purpose and rise in service.

    ,  ,     . 

To step into CAFS is to step into a garden of possibility   ,     .

        .          

#CAFSeedling
#CAFreshieS2025
#Freshies2025
#CAFS
#UPLB`;

        /**
         * Converts a string to its Mathematical Sans-Serif Bold Unicode equivalent.
         * Only converts English alphabet characters (A-Z, a-z) and digits (0-9).
         * Other characters are returned as is.
         * @param {string} text The input string.
         * @returns {string} The converted string.
         */
        function convertToMathSansBold(text) {
            let convertedText = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                if (charCode >= 65 && charCode <= 90) { // Uppercase A-Z
                    // 'A' (U+0041) to '' (U+1D5D4)
                    convertedText += String.fromCodePoint(charCode - 65 + 0x1D5D4);
                } else if (charCode >= 97 && charCode <= 122) { // Lowercase a-z
                    // 'a' (U+0061) to '' (U+1D5EE)
                    convertedText += String.fromCodePoint(charCode - 97 + 0x1D5EE);
                } else if (charCode >= 48 && charCode <= 57) { // Digits 0-9
                    // '0' (U+0030) to '' (U+1D7EC)
                    convertedText += String.fromCodePoint(charCode - 48 + 0x1D7EC);
                } else {
                    convertedText += text[i]; // Keep other characters as is
                }
            }
            return convertedText;
        }


        function showCaptionCustomizationModal() {
            captionCustomizationModal.classList.add('active');
            // Clear previous inputs and generated caption when opening
            personNameInput.value = '';
            degreeProgramSelect.value = ''; // Reset dropdown
            generatedCaptionDisplay.textContent = 'Your generated caption will appear here.';
            generatedCaption = "";
            copyCaptionBtn.textContent = 'COPY TO CLIPBOARD';
            copyCaptionBtn.disabled = false; // Enable copy button when modal opens
        }

        function hideCaptionCustomizationModal() {
            captionCustomizationModal.classList.remove('active');
        }

        captionModalCloseBtn.addEventListener('click', hideCaptionCustomizationModal);

        generateCaptionBtn.addEventListener('click', () => {
            const nickname = personNameInput.value.trim();
            const degreeProgram = degreeProgramSelect.value;

            if (!nickname || !degreeProgram) {
                showAlertModal("PLEASE ENTER A NICKNAME AND SELECT A DEGREE PROGRAM TO GENERATE THE CAPTION.", "INFORMATION");
                return;
            }

            // Apply the new font conversion to the nickname and degree program
            const formattedNickname = convertToMathSansBold(nickname);
            const formattedDegreeProgram = convertToMathSansBold(degreeProgram);

            let finalCaption = captionTemplate.replace('[nickname]', formattedNickname);
            finalCaption = finalCaption.replace('[degree program]', formattedDegreeProgram);
            
            generatedCaption = finalCaption;
            generatedCaptionDisplay.textContent = generatedCaption;
            copyCaptionBtn.disabled = false; // Enable copy button after generating
            copyCaptionBtn.textContent = 'COPY TO CLIPBOARD'; // Reset text if it was 'COPIED'
        });

        copyCaptionBtn.addEventListener('click', () => {
            if (generatedCaption) {
                // Use document.execCommand('copy') for better compatibility in iframes
                const textArea = document.createElement('textarea');
                textArea.value = generatedCaption;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    copyCaptionBtn.textContent = 'COPIED!';
                    copyCaptionBtn.disabled = true;
                    setTimeout(() => {
                        copyCaptionBtn.textContent = 'COPY TO CLIPBOARD';
                        copyCaptionBtn.disabled = false;
                    }, 2000); // Re-enable after 2 seconds
                } catch (err) {
                    console.error('FAILED TO COPY CAPTION: ', err);
                    showAlertModal("COULD NOT COPY CAPTION. PLEASE TRY MANUALLY.", "ERROR");
                }
                document.body.removeChild(textArea);
            } else {
                showAlertModal("PLEASE GENERATE A CAPTION FIRST.", "INFORMATION");
            }
        });

        // Event listener for "Choose Photo" button to open photo source modal
        const imageUploadTrigger = document.getElementById('imageUploadTrigger');
        imageUploadTrigger.addEventListener('click', () => {
            showPhotoSourceModal();
        });

        // Event listener for file input change
        document.getElementById('selectGalleryInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadImageAndSet(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        // Download Button
        document.getElementById('downloadBtn').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) {
                showAlertModal("PLEASE ADD A PHOTO TO THE FRAME FIRST!", "INFORMATION");
                return;
            }

            showLoadingOverlay("DOWNLOADING IMAGE..."); // Updated loading message

            // Simulate a 2-second delay before actual download
            setTimeout(() => {
                // Create a temporary canvas for the final high-resolution output
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                // Set tempCanvas dimensions to the natural resolution of the frame image
                // This ensures the downloaded image is high quality.
                tempCanvas.width = frameImage.naturalWidth;
                tempCanvas.height = frameImage.naturalHeight;

                // Calculate the scaling factor from the preview canvas to the high-res canvas
                const scaleRatio = tempCanvas.width / imageCanvas.width;

                tempCtx.clearRect(0, 0, tempCanvas.width, tempCtx.height);

                // 1. Draw blurred background for high-res output
                tempCtx.save();
                tempCtx.filter = 'blur(10px)'; // Blur amount might need adjustment for high-res

                // Apply flip to the blurred background for download
                tempCtx.translate(tempCanvas.width / 2, tempCtx.height / 2); // Translate to center for scaling
                tempCtx.scale(flipH, flipV);
                tempCtx.translate(-tempCtx.width / 2, -tempCtx.height / 2); // Translate back

                const bgAspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
                let bgDrawWidth, bgDrawHeight, bgDrawX, bgDrawY;

                if (bgAspectRatio > tempCanvas.width / tempCanvas.height) {
                    bgDrawHeight = tempCanvas.height;
                    bgDrawWidth = tempCanvas.height * bgAspectRatio;
                } else {
                    bgDrawWidth = tempCanvas.width;
                    bgDrawHeight = tempCanvas.width / bgAspectRatio;
                }
                bgDrawX = (tempCanvas.width - bgDrawWidth) / 2;
                bgDrawY = (tempCanvas.height - bgDrawHeight) / 2;
                tempCtx.drawImage(currentImage, bgDrawX, bgDrawY, bgDrawWidth, bgDrawHeight);
                tempCtx.restore();

                // 2. Draw the main user image with transformations and filters, scaled for high-res
                tempCtx.save();
                
                // Apply combined filters
                tempCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;

                // Scale transformations for high-resolution canvas
                let imgDisplayWidth = currentImage.naturalWidth * zoomLevel * scaleRatio;
                let imgDisplayHeight = currentImage.naturalHeight * zoomLevel * scaleRatio;

                let finalPanX = panX * scaleRatio;
                let finalPanY = panY * scaleRatio;

                tempCtx.translate(finalPanX + imgDisplayWidth / 2, finalPanY + imgDisplayHeight / 2);

                if (rotationAngle !== 0) {
                    tempCtx.rotate(rotationAngle);
                }

                tempCtx.scale(flipH, flipV);

                tempCtx.drawImage(currentImage, -imgDisplayWidth / 2, -imgDisplayHeight / 2, imgDisplayWidth, imgDisplayHeight);
                tempCtx.restore();
                tempCtx.filter = 'none'; // Reset filter

                // 3. Draw the frame on top (at its natural resolution)
                tempCtx.drawImage(frameImage, 0, 0, tempCanvas.width, tempCanvas.height);

                // Facebook overlay is intentionally NOT drawn for download

                // Get image data and trigger download
                const dataURL = tempCanvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = 'secret_garden_photo_frame.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                hideLoadingOverlay();
                showAlertModal("IMAGE DOWNLOADED SUCCESSFULLY!", "SUCCESS");
            }, 2000); // 2-second delay
        });

        // Finalize Picture Button - now "Add Caption"
        document.getElementById('finalizeBtn').addEventListener('click', () => {
            if (!currentImage || currentImage === defaultImage) {
                showAlertModal("PLEASE ADD A PHOTO TO THE FRAME FIRST TO ADD A CAPTION!", "INFORMATION");
                return;
            }
            showCaptionCustomizationModal();
        });

        // Countdown Timer Logic (Moved here from separate script block)
        const countdownContainer = document.querySelector('.countdown-container');

        const countdown = () => {
            const now = new Date().getTime();
            // Set the kickoff time to July 26, 2025, 7:00 PM (19:00:00) in the local timezone
            // Note: This date is hardcoded. If you need it to be dynamic, you'll need to update this line.
            const kickoff = new Date("Jul 26, 2025 19:00:00").getTime();
            const distance = kickoff - now;

            if (distance <= 0) {
                document.getElementById("days").textContent = "00";
                document.getElementById("hours").textContent = "00";
                document.getElementById("minutes").textContent = "00";
                document.getElementById("seconds").textContent = "00";

                // Fade out the countdown
                countdownContainer.classList.add('fade-out');

                // Remove from layout after fade
                setTimeout(() => {
                    countdownContainer.style.display = 'none';
                }, 1000);

                clearInterval(timerInterval);
                return;
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            document.getElementById("days").textContent = String(days).padStart(2, '0');
            document.getElementById("hours").textContent = String(hours).padStart(2, '0');
            document.getElementById("minutes").textContent = String(minutes).padStart(2, '0');
            document.getElementById("seconds").textContent = String(seconds).padStart(2, '0');
        };

        let timerInterval; // Declare timerInterval globally or in a scope accessible by countdown and window.onload

        // The timer will be started in window.onload after all assets are loaded.
    </script>
</body>
</html>